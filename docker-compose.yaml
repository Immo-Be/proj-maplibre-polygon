version: "3.8"
# We define a service called frontend. 
# This service will be built from the Dockerfile in the current directory.
# Services refer to the containers that will be created from the images.
services:
  app:
    # We use the Dockerfile in the current directory to build the image.
    # We could also use an image from Docker Hub, but we want to build
    # the image ourselves, so that we can use the Dockerfile to install
    # the dependencies.
    # The "." points to the Dockerfile in the current directory.
    build: .
    # If we wanted to add build-time arguments, we could do it like this:
    # build:
    #   context: .
    #   args:
    #     - NODE_ENV=production
    #     - PORT=3000
    # We could then use the arguments in the Dockerfile like this:
    # ARG NODE_ENV
    # ARG PORT
    # ENV NODE_ENV=$NODE_ENV
    # ENV PORT=$PORT
    # We could also point to .env files, like this:
    # env_file:
    #   - ./.env
    #   - ./.env.dev
    #   - ./.env.prod
    # We could then use the variables in the Dockerfile like this:
    # ENV NODE_ENV=$NODE_ENV
    # ENV PORT=$PORT
    # We could also use the variables in the docker-compose.yml file like this:
    # ports:
    #   - '${PORT}:${PORT}'
    # We could also use the variables in the Dockerfile like this:
    # RUN echo "The port is ${PORT}"
    volumes:
      # We mount the current directory to /app in the container.
      # This means that any changes to the files in the current directory
      # will be reflected in the container.
      # This is useful during development, because we can edit the files
      # on the host, and the changes will be reflected in the container.
      # This is called a bind mount.<
      # Here, we do not have to specify the full path to the current directory,
      # because docker-compose will automatically set the current directory
      # as the context for the build. (unlike docker build, where we have to)
      - ./:/app/
      # We copy copy all files from the host to the container,
      # but we don't want to copy node_modules, because we want to use the
      # node_modules from the container, not the host.
      # So we add a volume to the container, which will be used to store
      # node_modules.
      # We could avoid this by copying only the source code ( - /src:/app/src)
      - /app/node_modules 
    # We expose port 3000, so that we can access the frontend from the host.
    ports:
      - '3000:3000'
    depends_on:
      - pocketbase_db
    # environment:
    #   DATABASE_URL: postgres://baeldung:baeldung@db:5432/postgres
    # We set stdin_open and tty to true, so that we can use the container
    # as if it was a process running on the host. (e.g. we can use ctrl+c to stop it)
    # With docker run, we would have to use the -it flag.
    stdin_open: true
    tty: true

  pocketbase_db:
    build:
      context: .
      dockerfile: Dockerfile.db
      args:
        TARGETOS: linux
        TARGETARCH: amd64
        VERSION: 0.2.8
    ports:
      - "8090:8090"
    # command: ["serve", "--http=0.0.0.0:8090"]
    stdin_open: true
    tty: true
    volumes:
      - ./pb_data:/pb/pb_data

  # db:
  #       image: postgres:13
  #       restart: always
  #       environment:
  #         POSTGRES_PASSWORD: password
  # db:
  #   image: postgres:16.2
  #   container_name: postgressql_db
  #   environment:
  #     POSTGRES_USER: baeldung
  #     POSTGRES_PASSWORD: baeldung
  #   ports:
  #     - "5432:5432"
  #   # volumes:
  #   #   - /data:/var/lib/postgresql/data
  #   restart: always
